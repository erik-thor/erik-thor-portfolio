'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _fastdom = require('./fastdom');

// Finds element's position relative to the whole document,
// rather than to the viewport as it is the case with .getBoundingClientRect().
var getElementPosition = function getElementPosition(elementClientRect, windowProps) {
  var top = elementClientRect.top,
      left = elementClientRect.left;
  var pageXOffset = windowProps.pageXOffset,
      pageYOffset = windowProps.pageYOffset;

  return {
    top: top + pageYOffset,
    left: left + pageXOffset
  };
};

var inViewport = function inViewport(element, container, customOffset) {
  return Promise.all([(0, _fastdom.getBoundingClientRect)(element), (0, _fastdom.getElementBox)(element), (0, _fastdom.getWindowProps)()]).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        elementClientRect = _ref2[0],
        elementBox = _ref2[1],
        windowProps = _ref2[2];

    if (!element || elementBox.offsetParent === null) return false;

    if (typeof container === 'undefined' || container === window) {
      var pageXOffset = windowProps.pageXOffset,
          pageYOffset = windowProps.pageYOffset,
          innerWidth = windowProps.innerWidth,
          innerHeight = windowProps.innerHeight;

      return {
        left: pageXOffset,
        top: pageYOffset,
        right: pageXOffset + innerWidth,
        bottom: pageYOffset + innerHeight,
        elementClientRect: elementClientRect,
        elementBox: elementBox,
        windowProps: windowProps
      };
    }

    return Promise.all([(0, _fastdom.getBoundingClientRect)(container), (0, _fastdom.getElementBox)(container)]).then(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          containerClientRect = _ref4[0],
          containerBox = _ref4[1];

      var containerPosition = getElementPosition(containerClientRect, windowProps);
      var top = containerPosition.top,
          left = containerPosition.left;
      var offsetWidth = containerBox.offsetWidth,
          offsetHeight = containerBox.offsetHeight;

      return {
        left: left,
        top: top,
        right: left + offsetWidth,
        bottom: top + offsetHeight,
        elementClientRect: elementClientRect,
        elementBox: elementBox,
        windowProps: windowProps
      };
    });
  }).then(function (result) {
    if (!result) return false; // element doesn't exist or it isn't in the DOM tree.

    var elementClientRect = result.elementClientRect,
        elementBox = result.elementBox,
        windowProps = result.windowProps,
        top = result.top,
        left = result.left,
        bottom = result.bottom,
        right = result.right;

    var elementPosition = getElementPosition(elementClientRect, windowProps);

    return top <= elementPosition.top + elementBox.offsetHeight + customOffset.top && bottom >= elementPosition.top - customOffset.bottom && left <= elementPosition.left + elementBox.offsetWidth + customOffset.left && right >= elementPosition.left - customOffset.right;
  });
};

exports.default = inViewport;